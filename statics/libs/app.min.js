APPNAME = 'lab'
getPartial = function( path )
{
	return '/statics/partials/' + path;
} 

angular
	.module( APPNAME, [])
;

// console.group('Good day to you sir!');
// console.log("         #              ");
// console.log("        ###             ");
// console.log("      ### ###           ");
// console.log("     ###   ###          ");
// console.log("   ###         #######  ");
// console.log("  ###       #######     ");
// console.log(" #########     ###      ");
// console.log("###.            ###     ");
// console.log('');
// console.log("I'm a freelance creative technologist.");
// console.log("You have a project? Let's talk!");
// console.log('hello@alexandremasy.com');
// console.log('http://linkedin.com/in/amasy/');
// console.log('');
// console.log("You want more ?");
// console.log("http://github.com/ahsx");
// console.log("http://twitter.com/beg_sleep");
// console.log('');
// console.groupEnd('Good day to you sir!')

var f = 0;
function setFrequency( value )
{
	TweenMax.to( this, 1, {f:value, onUpdate:commit});
}
function commit()
{
	window.mud.setFrequency( f );
}
angular
	.module( APPNAME )
	.controller('AppController', ['$rootScope', '$scope', function($rootScope, $scope)
	{
		$rootScope.open = false;
		$rootScope.openSide = 'options';
		$rootScope.options = {};

		/**
		 *	Save to clipboard
		 *
		 *	@param text {String}
		 **/
		$scope.saveToClipboard = function( text )
		{
			window.prompt("Copy to clipboard: Ctrl+C, Enter", text);
		}

		/**
		 *	Track the social information into Google Analytics
		 *	
		 *	@param network {String}
		 *	@param action {String}
		 **/
		$scope.trackSocial = function( network, action )
		{
			ga('send', 'social', network, action, window.location.href);
		}
	}]);
angular
	.module( APPNAME )
	.controller('ScreenplayController', ['$scope', '$rootScope', '$element',  '$window', 'CanvasService', function($scope, $rootScope, $element, $window, CanvasService)
	{
		CanvasService.init( $element.find('canvas'), jQuery($element).find('.container'), $window );
		$rootScope.saveCanvas = function()
		{
			$rootScope.saveURL = CanvasService.getURL();
			window.location.href = $rootScope.saveURL;
		}

		$scope.$watchCollection( 'options', function(newVal, oldVal)
		{
			CanvasService.update( newVal );
		})
	}])
;
angular
	.module( APPNAME )
	.directive('description', [function(){
		// Runs during compile
		return {
			// name: '',
			// priority: 1,
			// terminal: true,
			// scope: {}, // {} = isolate, true = child, false/undefined = no change
			controller: function($scope, $element, $attrs, $transclude) 
			{
				$scope.title = $attrs.title || 'Warning: untitled application';
				$scope.subtitle = $attrs.subtitle || '';
				$scope.github = $attrs.github || 'Warning: no url defined';
				$scope.demo = $attrs.demo || 'Warning: no url defined';
				$scope.keywords = $attrs.keywords || 'Warning, no, keywords';
				$scope.image = $attrs.image || 'Warning: no image defined';
			},
			// require: 'ngModel', // Array = multiple requires, ? = optional, ^ = check parent elements
			restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
			// template: '',
			// templateUrl: getPartial('directives/description.html'),
			// replace: true,
			// transclude: true,
			// compile: function(tElement, tAttrs, transclude)
			// { 
			// 	return {
			// 		pre: function($scope)
			// 		{
			// 			transclude($scope, function(clone)
			// 			{
			// 				$scope.description = clone[0].textContent || 'Warning: no application description';
			// 			})
			// 		}
			// 	}
			// },
			link: function($scope, iElm, iAttrs, controller) {
				
			}
		};
	}]);
angular
	.module( APPNAME )
	.directive('dropdown', [function()
	{
		// Runs during compile
		return {
			// name: '',
			// priority: 1,
			// terminal: true,
			scope: {
				title: '@',
				value: '=model'
			}, // {} = isolate, true = child, false/undefined = no change
			// controller: function($scope, $element, $attrs, $transclude) {},
			// require: 'ngModel', // Array = multiple requires, ? = optional, ^ = check parent elements
			restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
			// template: '',
			templateUrl: getPartial('directives/dropdown.html'),
			// replace: true,
			transclude: true,
			// compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn){ return function linking(scope, elm, attrs){}})),
			// link: function($scope, iElm, iAttrs, controller) {
			// }
		};
	}]);
angular
	.module( APPNAME )
	.directive('icon', [function(){
		// Runs during compile
		return {
			// name: '',
			// priority: 1,
			// terminal: true,
			scope: {}, // {} = isolate, true = child, false/undefined = no change
			controller: function($scope, $element, $attrs, $transclude) 
			{
				$scope.label = $attrs.label;
				$scope.href = '#' + $attrs.label;
				$scope.width = $attrs.width || 32;
				$scope.height = $attrs.height || 32;

			},
			// require: 'ngModel', // Array = multiple requires, ? = optional, ^ = check parent elements
			restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
			// template: '',
			templateUrl: getPartial('directives/icon-directive.html'),
			// replace: true,
			// transclude: true,
			// compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn){ return function linking(scope, elm, attrs){}})),
			link: function($scope, iElm, iAttrs, controller) {
				
			}
		};
	}]);
/**
 *	Range directive
 *	
 *	Display a range component. 
 *
 *	Parameters:
 * 		- min {Number} Minimun value allowed
 * 		- max {Number} Maximum value allowed
 * 		- title {String} Title displayed in the label
 * 		- step {Number}	Each time we click on + and - how much do we add or retract
 * 		- precision {Number} What is the precision of the display
 * 		- value {Number} The initial value
 * 		- movel {String} Where do we store the value (which scope variable)
 *
 *	@author Alexandre Masy
 *	@version 1.2
 **/
angular
	.module( APPNAME )
	.directive('range', [function(){
		// Runs during compile
		return {
			// name: '',
			// priority: 1,
			// terminal: true,
			scope: {
				min: 		'@',
				max: 		'@',
				title: 		'@',
				step: 		'@',
				precision: 	'@',
				value: 		'=model'
			}, // {} = isolate, true = child, false/undefined = no change
			// controller: function($scope, $element, $attrs, $transclude) {},
			// require: '^', // Array = multiple requires, ? = optional, ^ = check parent elements
			restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
			// template: '',
			templateUrl: getPartial('directives/range.html'),
			// replace: true,
			// transclude: true,
			// compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn){ return function linking(scope, elm, attrs){}})),
			link: function($scope, $element, $attrs, controller) 
			{
				$scope.value = $attrs.value || 0;
				$scope.step = parseFloat($attrs.step) || 1;
				$scope.precision = $attrs.precision || 1;

				$scope.plus = function()
				{
					var n = parseFloat($scope.value) + $scope.step;
					$scope.value = Math.min( n, $attrs.max );
				}

				$scope.minus = function()
				{
					var n = parseFloat($scope.value) - $scope.step;
					$scope.value = Math.max( n, $attrs.min );
				}
			}
		};
	}]);
"use strict";

/**
* SVG Collection directive
*
* Description
*/
angular
	.module( APPNAME )
	.directive('sprite', [function(){
		// Runs during compile
		return {
			// name: '',
			// priority: 1,
			// terminal: true,
			// scope: {}, // {} = isolate, true = child, false/undefined = no change
			// controller: function($scope, $element, $attrs, $transclude) {},
			// require: 'ngModel', // Array = multiple requires, ? = optional, ^ = check parent elements
			restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
			// template: '',
			templateUrl: getPartial('directives/svg-sprite.html'),
			// replace: true,
			// transclude: true,
			// compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn){ return function linking(scope, elm, attrs){}})),
			link: function($scope, iElm, iAttrs, controller) {
				
			}
		};
	}]);
angular
	.module( APPNAME )
	.directive('switch', [function(){
		// Runs during compile
		return {
			// name: '',
			// priority: 1,
			// terminal: true,
			scope: {
				labelon: 	'@',
				labeloff: 	'@',
				on: 		'@',
				title: 		'@',
				value: 		"=model"
			}, // {} = isolate, true = child, false/undefined = no change
			// controller: function($scope, $element, $attrs, $transclude) {},
			// require: 'ngModel', // Array = multiple requires, ? = optional, ^ = check parent elements
			restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
			// template: '',
			templateUrl: getPartial('directives/switch.html'),
			// replace: true,
			// transclude: true,
			// compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn){ return function linking(scope, elm, attrs){}})),
			link: function($scope, iElm, iAttrs, controller) {
				$scope.value = iAttrs.on === 'true';
			}
		};
	}]);
angular
	.module( APPNAME )
	.directive('toolbar', [function(){
		// Runs during compile
		return {
			// name: '',
			// priority: 1,
			// terminal: true,
			// scope: {}, // {} = isolate, true = child, false/undefined = no change
			// controller: function($scope, $element, $attrs, $transclude) {},
			// controller: 'ToolbarController',
			// require: 'ngModel', // Array = multiple requires, ? = optional, ^ = check parent elements
			restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
			// template: '',
			templateUrl: getPartial('directives/toolbar.html'),
			replace: true,
			transclude: true,
			// compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn){ return function linking(scope, elm, attrs){}})),
			link: function($scope, iElm, iAttrs, controller) {
				// controller.init(iElm)	
			}
		};
	}]);
angular
	.module( APPNAME )
	.directive('toolbaritem', ['$rootScope', function($rootScope){
		// Runs during compile
		return {
			// name: '',
			// priority: 1,
			// terminal: true,
			scope: true, // {} = isolate, true = child, false/undefined = no change
			controller: function($scope, $element, $attrs, $transclude) 
			{
				$scope.active = false;
				$scope.title = $attrs.title;
				$scope.href = $attrs.href;
				$scope.icon = $attrs.icon;
				$scope.side = $attrs.href.substr(1);

				$rootScope.$watch('openSlide', function(newVal, oldVal)
				{
					$scope.active = $rootScope.openSlide == $scope.side;
				});

				$scope.itemClick = function( $event, side )
				{
					$event.preventDefault();

					ga('send', 'event', 'Toolbar', 'Click', side);

					if ( $scope.side == $scope.openSlide )
					{
						$rootScope.open = !$rootScope.open;
					}
					else
					{
						$rootScope.open = true;
						$rootScope.openSlide = $scope.side;
					}

					if ( !$rootScope.open )
						$rootScope.openSlide = null;
				}
			},
			// require: 'ngModel', // Array = multiple requires, ? = optional, ^ = check parent elements
			restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
			// template: '',
			templateUrl: getPartial('directives/toolbar-item.html'),
			replace: true,
			// transclude: true,
			// compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn){ return function linking(scope, elm, attrs){}})),
			link: function($scope, iElm, iAttrs, controller) {
				
			}
		};
	}]);
angular
	.module( APPNAME )
	.directive('fade', [function($animate)
	{
		// Runs during compile
		return {
			// name: '',
			// priority: 1,
			// terminal: true,
			scope: true, // {} = isolate, true = child, false/undefined = no change
			controller: function($scope, $element, $attrs, $transclude) 
			{
			},
			// require: 'ngModel', // Array = multiple requires, ? = optional, ^ = check parent elements
			restrict: 'A', // E = Element, A = Attribute, C = Class, M = Comment
			// template: '',
			// templateUrl: '',
			// replace: true,
			// transclude: true,
			// compile: function(tElement, tAttrs, function transclude(function(scope, cloneLinkingFn){ return function linking(scope, elm, attrs){}})),
			link: function($scope, iElm, iAttrs, controller) {
				
			}
		};
	}]);
angular
	.module(APPNAME)
	.service('CanvasService', ['Utils', function(Utils)
	{
		/**
		 *	Return the url of the image of the canvas
		 *
		 *	@return {String}
		 **/
		this.getURL = function()
		{
			return this.canvas[0].toDataURL('image/png').replace("image/png", "image/octet-stream");;
		}

		/**
		 *	Define the composite operation
		 *	
		 *	@param value String
		 **/
		this.setComposite = function( value )
		{
			if ( value == this.composite && !value )
				return;

			this.composite = value;
			var n = this.maxLayers;
			while( n-- )
			{
				this.layers[n].setComposite( value )
			}
		}

		/**
		 *	Define the number of points
		 *
		 *	@param value uint
		 **/
		this.setNPoints = function( value )
		{
			value = value|0;
			if ( value == this.npoints || value == 0 )
				return;

			this.npoints = value;
			var n = this.maxLayers;
			while( n-- )
			{
				this.layers[n].setNPoints( value )
			}	
		}

		/**
		 *	Define the number of layer
		 *
		 *	@param value uint
		 **/
		this.setNLayers = function( value )
		{
			value = value|0;
			if ( value == this.nLayers || value == 0 )
				return;

			this.nLayers = value;

			// muds
			var n = this.maxLayers;
			var avg = this.maxLayers/this.nLayers | 0;
			var avgh = (this.pixelHeight*.1*8.5) / (this.maxLayers);
			var m, s, a, h = 0;
			var i = 0, y = 0;
			while( n-- )
			{
				m = this.layers[n];
				s = m.getDisplayObject();
				a = n % avg == 0;
				if ( a ) 
					i++;

				h += avgh;

				m.setActive( a );
				y = a ? this.pixelHeight - h + Utils.range(-10, 20) : this.pixelHeight - i*10;
				TweenMax.to( s, 1, {y:y});
			}
		}

		/**
		 *	Init the canvas
		 *
		 *	@param canvas JQueryElement
		 *	@param container JQueryElement
		 *	@param value Window
		 **/
		this.init = function( canvas, container, window )
		{
			this.canvas = jQuery(canvas);
			this.context = canvas[0].getContext('2d');
			this.stage = new createjs.Stage( canvas[0] );
			createjs.Ticker.addEventListener("tick", onTickHandler.bind(this));
				
			var c = new klr( Utils.range(0, 255),Utils.range(0, 255),Utils.range(0, 255) );
			c = '#'+c.format('string');

			this.maxLayers = 30;
			this.nLayers = 6;
			this.colors = getColors( c, this.maxLayers+2 );
			this.layers = [];

			var k = klr.fromHex(this.colors[this.maxLayers-1]);
			k = k.toMonochrome();
			this.bgColor = '#'+k.getList()[1].format('string');

			this.container = container;
			this.background = null;

			this.window = jQuery(window).on('resize', onResizeHandler.bind(this));
			this.create();
			this.refresh();
		}

		/**
		 *	Refresh the value // on resize window
		 **/
		this.refresh = function()
		{
			this.windowWidth = this.window.width();
			this.windowHeight = this.window.height();
		}

		/** 
		 *	Create the objects
		 **/
		this.create = function()
		{
			// background
			this.stage.addChild( this.background = new createjs.Shape() );

			// muds
			var n = this.maxLayers;
			var m;
			var h;
			while( n-- )
			{
				m = new Mud( this.colors[n], 6, 100, .25);
				m.setUtils( Utils );

				if ( n > this.nLayers )
					m.setActive( false );

				this.stage.addChild( m.getDisplayObject() );
			
				this.layers.push( m );
			}
		}

		/**
		 *	The value have change, needs to adapt to the new values
		 *	
		 *	@param options Object
		 **/
		this.update = function( options )
		{
			this.setSize( options.stageWidth, options.stageHeight );
			this.setComposite( options.composite );
			this.setNPoints( options.nPoints );
			this.setNLayers( options.nLayers );
		}

		/**
		 *	Called every frame
		 **/
		this.draw = function()
		{
			// muds
			var n = this.maxLayers;
			while( n-- )
			{
				this.layers[n].draw();
			}

		}

		/**
		 *	Define the size of the canvas
		 *
		 *	@param width Number %
		 *	@param height Number %
		 **/	
		this.setSize = function( width, height )
		{
			if ( width == undefined || height == undefined )
				return;

			this.width = width;
			this.height = height;

			var offset = 70;
			var pw = this.windowWidth * (width*.01) - offset;
			var ph = this.windowHeight * (height*.01);
			
			if ( pw == this.pixelWidth && ph == this.pixelHeight )
				return;

			this.pixelWidth = pw;
			this.pixelHeight = ph;

			console.group('CanvasService::SetSize');
			console.log('% 	- %s 	x 	%s', width, height);
			console.log('px 	- %s 	x 	%s', this.pixelWidth, this.pixelHeight);
			console.groupEnd();

			this.container.css({
				width: "calc("+width+"% - 70px)",
				height: height +'%'
			})

			this.canvas.attr({
				width: this.pixelWidth,
				height: this.pixelHeight
			});

			// muds
			var n = this.maxLayers;
			var s;
			var m;
			var avgh = (this.pixelHeight*.1*8.5) / (this.maxLayers);
			var h = 0;
			var y = 0;
			while( n-- )
			{
				m = this.layers[n];
				s = m.getDisplayObject();
				h += avgh;

				m.setSize( this.pixelWidth, h );
				s.y = this.pixelHeight - h + Utils.range(-10, 20);
			}

			// bg
			this.background.graphics
								.clear()
								.beginFill( this.bgColor )
								.drawRect( 0, 0, this.pixelWidth, this.pixelHeight )
								.endFill();
		}

		
		/**
		 *	Return a color list based on a color
		 *
		 *	@param color String
		 *	@param qty uint
		 **/
		function getColors( color, qty )
		{
			var k = klr.fromHex(color);
			var l = k.toLight(qty);
			l.sortBySaturation();
			l = l.getList();
			var ret = [];
			var n = l.length-1;
			var i = -1;
			while( n-- )
			{
				k = l[n];
				ret.push( '#'+k.format('string') );
			}

			return ret;
		}

		/**
		 *	Resize handler
		 *
		 *	@param event
		 **/
		function onResizeHandler(event)
		{
			this.refresh();
			this.width !== null && this.setSize( this.width, this.height );
		}

		/**
		 *	Tick handler
		 *	
		 *	@param event TickEvent
		 **/
		function onTickHandler(event)
		{
			this.draw();
			this.stage.update();
		}
	}]);
(function(window) {
	'use strict';

	
	/**
	 *	El constructor
	 *
	 *	@param color uint
	 *	@param amplitude int
	 *	@param npoints int
	 **/
	function Mud( color, npoints, amplitude, frequency )
	{
		this.color = color;
		this.nPoints = npoints;
		this.amplitude = amplitude;
		this.frequency = frequency;
		this.maxPoints = 30;
		this.needDraw = false;
		this.active = true;

		var k = klr.fromHex( this.color );
		this.rgba = "rgba({red},{green},{blue}, .4)"
						.replace('{red}', k.getRed() )
						.replace('{green}', k.getGreen() )
						.replace('{blue}', k.getBlue() )



		this.shape = new createjs.Shape();
	}

	/**
	 * 	prototype
	 **/
	var p = Mud.prototype;
	
	/**
	 *	Return the display object
	 *	
	 *	@return DisplayObject
	 **/
	p.getDisplayObject = function()
	{
		return this.shape;
	}

	/**
	 *	Define the utility methods
	 *
	 *	@param utils Utils
	 **/
	p.setUtils = function( utils )
	{
		this.utils = utils;
	}

	/**
	 *	Define the size of the layer
	 *
	 *	@param width Number
	 *	@param height Number
	 *	@return Mud
	 **/
	p.setSize = function( width, height )
	{
		this.width = width;
		this.height = height;

		this.reset();
		this.compute();

		return this;
	}

	/**
	 *	Define the frequency of the mud wave
	 *
	 *	@param value Number
	 * 	@return Mud
	 **/
	p.setFrequency = function( value )
	{
		this.frequency = value;

		this.reset();
		this.compute();

		return this;
	}

	/**
	 *	Define the composite operation
	 *
	 *	@param value String
	 *	@return Mud
	 **/
	p.setComposite = function( value )
	{
		this.composite = value;
		this.shape.compositeOperation = value;

		return this;
	}

	/**
	 *	Define the n points
	 *
	 *	@param value uint
	 *	@return Mud
	 **/
	p.setNPoints = function( value )
	{
		this.nPoints = value;
		this.compute();

		return this;
	}

	/**
	 *	Activate or deactivate the mud
	 *	
	 *	@param value Boolean
	 **/
	p.setActive = function( value )
	{
		this.active = value == true;

		if ( this.list && this.list.length > 0 )
			this.compute();
	}

	/**
	 *	Compute all the available points
	 */
	p.reset = function()
	{
		this.list = [];

		var n = this.maxPoints;
		var i = -1;
		var avg = this.width / n;
		var increase = Math.PI / (this.maxPoints*.3*2);
		var counter = 0;
		var x, y = 0;

		var maxx = avg * (1+this.frequency);
		var minx = avg / (1+this.frequency);

		var miny, maxy;
		var px = 0;

		while( i++ < n )
		{
			x = i * avg;
			px += this.utils.range( minx, maxx );
			px = Math.min( px, this.width );

			y = Math.sin( counter ) * this.amplitude;
			miny = y * (1+this.frequency);
			maxy = y / (1+this.frequency);
			y = this.utils.range( miny, maxy );

			counter += increase;

			p = {x:px|0, y:-y|0}
			this.list.push(p);
		}
	}

	/**
	 *	Select the points to be drawn and animate them
	 **/
	p.compute = function ()
	{
		var old = this.points;
		this.points = [];
		var n = this.list.length-1;
		var c = this.nPoints;
		var a = n / c | 0;
		var i = -a;
		var j = -1;
		var p;
		var x = 0, y = 0;
		var index;

		while ( i < n )
		{
			i += a;
			i = Math.min( i, n );
			j++;
			
			if ( this.active )
			{
				p = this.list[i];
				x = p.x;
				y = p.y;
				p = {x:x, y:y};
				
				// 
				if ( old && old.length > j )
				{
					p.x = old[j].x;
					p.y = old[j].y;
				}
				else
				{
					p.x = this.width;
					p.y = 0;
				}
			}
			else if ( old && old.length > j )
			{
				p = {
					x:old[j].x,
					y:old[j].y
				};
			}
			else
			{
				p = {
					x:x,
					y:y
				}
			}

			TweenMax.to( p, 1, {x:x, y:y});
			this.points.push( p );
		}
	}

	/**
	 *	Draw the layer
	 *
	 *	@return Layer
	 **/
	p.draw = function()
	{
		this.shape.graphics.clear();

		// debug
		var stroke = 1;
		var n = this.nPoints;
		var i = 0;
		var p = this.points[i];

		this.shape.graphics
					.beginStroke( this.color )
					.setStrokeStyle( stroke )
					.beginFill( this.rgba )
					.moveTo( 0, p.y )


		while( i++ < n )
		{
			p = this.points[i];
			this.shape.graphics
						.lineTo( p.x-stroke, p.y )
		}

		this.shape.graphics
					// .endStroke()
					.lineTo( this.width, p.y )
					.lineTo( this.width, 0 )
					.lineTo( this.width, this.height )
					.lineTo( 0, this.height )
					.endFill()
					;
		

		return this;
	}

	window.Mud = Mud;

})(window);
angular
	.module( APPNAME )
	.service('Utils', [function(){
		
		/**
		 *	Return a random value between min and max
		 *
		 *	@param min {Number}
		 *	@param max {Number}
		 *	@return {Number}
		 **/
		this.range = function( min, max )
		{
			return Math.floor(Math.random() * (max - min + 1) + min);
		}

		/**
		 *	Convert a degree angle to a radian
		 *
		 *	@param value {Number}
		 *	@return {Number}
		 **/
		this.toRadian = function( value )
		{
			return value * (Math.PI/180);
		}
	}])	
